<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhuzhuzai.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="操作系统中断相关知识，从异常，中断和系统调用三个方面来讲述">
<meta property="og:type" content="article">
<meta property="og:title" content="中断">
<meta property="og:url" content="https://zhuzhuzai.top/2022/04/27/note/%E4%B8%AD%E6%96%AD/index.html">
<meta property="og:site_name" content="Zzzai&#39;s Blog">
<meta property="og:description" content="操作系统中断相关知识，从异常，中断和系统调用三个方面来讲述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgimage-20220426205810991.png">
<meta property="og:image" content="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgx86%20%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgx86-interrupt%20call.png">
<meta property="og:image" content="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgimage-20220426212350991.png">
<meta property="article:published_time" content="2022-04-26T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-07T11:35:05.119Z">
<meta property="article:author" content="Zhuzhuzai">
<meta property="article:tag" content="os">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgimage-20220426205810991.png">


<link rel="canonical" href="https://zhuzhuzai.top/2022/04/27/note/%E4%B8%AD%E6%96%AD/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhuzhuzai.top/2022/04/27/note/%E4%B8%AD%E6%96%AD/","path":"2022/04/27/note/中断/","title":"中断"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>中断 | Zzzai's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zzzai's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">1.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#misc"><span class="nav-number">1.1.</span> <span class="nav-text">misc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.1.</span> <span class="nav-text">异常向量初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">异常向量处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E4%BB%8E%E7%94%A8%E6%88%B7%E6%80%81%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.3.</span> <span class="nav-text">真正的从用户态陷入内核态执行的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%A7%8B%E6%9C%89%E7%BB%88"><span class="nav-number">1.2.4.</span> <span class="nav-text">有始有终</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.1.</span> <span class="nav-text">中断向量初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">中断处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9C%9F%E6%AD%A3%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">1.3.3.</span> <span class="nav-text">真正陷入内核态执行的地方</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#int-0x80"><span class="nav-number">1.4.1.</span> <span class="nav-text">int 0x80</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SYSCALL-SYSENTER%E6%8C%87%E4%BB%A4%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">SYSCALL&#x2F;SYSENTER指令方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">寄存器初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8SYSCALL%E6%8C%87%E4%BB%A4%E5%89%8D%E5%90%8E"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">调用SYSCALL指令前后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do-syscall-64%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">do_syscall_64进行系统调用处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">1.5.</span> <span class="nav-text">Reference</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuzhuzai"
      src="/images/portrait.gif">
  <p class="site-author-name" itemprop="name">Zhuzhuzai</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/unsatisfying" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;unsatisfying" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:824941284@qq.com" title="E-Mail → mailto:824941284@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhuzhuzai.top/2022/04/27/note/%E4%B8%AD%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portrait.gif">
      <meta itemprop="name" content="Zhuzhuzai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zzzai's Blog">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="中断 | Zzzai's Blog">
      <meta itemprop="description" content="操作系统中断相关知识，从异常，中断和系统调用三个方面来讲述">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          中断
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-27T00:00:00+08:00">2022-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-07 19:35:05" itemprop="dateModified" datetime="2025-10-07T19:35:05+08:00">2025-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">操作系统中断相关知识，从异常，中断和系统调用三个方面来讲述</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>​	说到中断离不开处理器架构，在x86架构下同步的称为异常，异步的称为中断，其区别为：</p>
<ul>
<li>中断：中断分为可屏蔽中断和不可屏蔽中断，其可以发生在指令执行的任何时间，其中可屏蔽中断是由外部设备发出的中断，不可屏蔽中断通过NMI引脚接入CPU。</li>
<li>异常：指的是CPU执行指令的同时发现执行该指令出错，可以分为处理器检测异常和编程异常，其中处理器检测异常包括故障，陷阱，终止；编程异常包括程序调用int等指令时发出的异常（这种异常有时候也被成为软中断，命名问题，本文称其为异常）</li>
</ul>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><p>本文基于Linux-5.15。主要涉及中断处理，异常处理，系统调用三个方面的函数调用以及Linux处理逻辑，防止混淆。硬件上的内容就不说了，都耳熟能详了。</p>
<p>在<code>arch/x86/include/asm/irq_vectors.h</code>中列了一些宏，用以表示<code>IDT</code>表的一些布局情况，其中可以知道</p>
<ul>
<li>Vectors   0 …  31 	: system traps and exceptions - hardcoded events</li>
<li>Vectors  32 … 127   : device interrupts</li>
<li>Vector  128              : legacy int80 syscall interface</li>
<li>Vectors 129 … LOCAL_TIMER_VECTOR-1</li>
<li>Vectors LOCAL_TIMER_VECTOR … 255 : special interrupts</li>
</ul>
<p>其中0 ~ 31号为CPU保留的异常，32 ~ 127号为外部设备中断，128号为系统调用。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>先从异常处理开始吧，因为异常是在表中是0~31号向量。</p>
<p>在文件<code>arch/x86/include/asm/trapnr.h</code>中保存了异常向量的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_DE		 0	<span class="comment">/* Divide-by-zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_DB		 1	<span class="comment">/* Debug */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_NMI		 2	<span class="comment">/* Non-maskable Interrupt */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_BP		 3	<span class="comment">/* Breakpoint */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_OF		 4	<span class="comment">/* Overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_BR		 5	<span class="comment">/* Bound Range Exceeded */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_UD		 6	<span class="comment">/* Invalid Opcode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_NM		 7	<span class="comment">/* Device Not Available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_DF		 8	<span class="comment">/* Double Fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_OLD_MF		 9	<span class="comment">/* Coprocessor Segment Overrun */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_TS		10	<span class="comment">/* Invalid TSS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_NP		11	<span class="comment">/* Segment Not Present */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_SS		12	<span class="comment">/* Stack Segment Fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_GP		13	<span class="comment">/* General Protection Fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_PF		14	<span class="comment">/* Page Fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_SPURIOUS	15	<span class="comment">/* Spurious Interrupt */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_MF		16	<span class="comment">/* x87 Floating-Point Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_AC		17	<span class="comment">/* Alignment Check */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_MC		18	<span class="comment">/* Machine Check */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_XF		19	<span class="comment">/* SIMD Floating-Point Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_VE		20	<span class="comment">/* Virtualization Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_CP		21	<span class="comment">/* Control Protection Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_VC		29	<span class="comment">/* VMM Communication Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_IRET		32	<span class="comment">/* IRET Exception */</span></span></span><br></pre></td></tr></table></figure>



<h3 id="异常向量初始化"><a href="#异常向量初始化" class="headerlink" title="异常向量初始化"></a>异常向量初始化</h3><p>首先启动内核时候，需要初始化异常向量表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start_kernel()  <span class="comment">//init/main.c</span></span><br><span class="line"> -&gt;trap_init() 	<span class="comment">//arch/x86/kernel/traps.c</span></span><br><span class="line">  -&gt;idt_setup_traps()	<span class="comment">//arch/x86/kernel/idt.c</span></span><br><span class="line">   -&gt;idt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>上面最后调用在函数<code>idt_setup_from_table</code>中，我们看看这个函数的几个参数定义。在<code>arch/x86/kernel/idt.c</code>中定义了idt表和描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">desc_ptr</span> <span class="title">idt_descr</span> __<span class="title">ro_after_init</span> =</span> &#123;</span><br><span class="line">	.size		= IDT_TABLE_SIZE - <span class="number">1</span>,</span><br><span class="line">	.address	= (<span class="type">unsigned</span> <span class="type">long</span>) idt_table,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> __initconst <span class="class"><span class="keyword">struct</span> <span class="title">idt_data</span> <span class="title">def_idts</span>[] =</span> &#123;</span><br><span class="line">	INTG(X86_TRAP_DE,		asm_exc_divide_error),</span><br><span class="line">	ISTG(X86_TRAP_NMI,		asm_exc_nmi, IST_INDEX_NMI),</span><br><span class="line">	INTG(X86_TRAP_BR,		asm_exc_bounds),</span><br><span class="line">	INTG(X86_TRAP_UD,		asm_exc_invalid_op),</span><br><span class="line">	INTG(X86_TRAP_NM,		asm_exc_device_not_available),</span><br><span class="line">	INTG(X86_TRAP_OLD_MF,		asm_exc_coproc_segment_overrun),</span><br><span class="line">	INTG(X86_TRAP_TS,		asm_exc_invalid_tss),</span><br><span class="line">	INTG(X86_TRAP_NP,		asm_exc_segment_not_present),</span><br><span class="line">	INTG(X86_TRAP_SS,		asm_exc_stack_segment),</span><br><span class="line">	INTG(X86_TRAP_GP,		asm_exc_general_protection),</span><br><span class="line">	INTG(X86_TRAP_SPURIOUS,		asm_exc_spurious_interrupt_bug),</span><br><span class="line">	INTG(X86_TRAP_MF,		asm_exc_coprocessor_error),</span><br><span class="line">	INTG(X86_TRAP_AC,		asm_exc_alignment_check),</span><br><span class="line">	INTG(X86_TRAP_XF,		asm_exc_simd_coprocessor_error),</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	ISTG(X86_TRAP_DF,		asm_exc_double_fault, IST_INDEX_DF),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	ISTG(X86_TRAP_DB,		asm_exc_debug, IST_INDEX_DB),</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">	ISTG(X86_TRAP_MC,		asm_exc_machine_check, IST_INDEX_MCE),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AMD_MEM_ENCRYPT</span></span><br><span class="line">	ISTG(X86_TRAP_VC,		asm_exc_vmm_communication, IST_INDEX_VC),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	SYSG(X86_TRAP_OF,		asm_exc_overflow),</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IA32_EMULATION)</span></span><br><span class="line">	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_X86_32)</span></span><br><span class="line">	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>idt_setup_from_table</code>函数本质就是将<code>def_idts</code>内容赋给<code>idt_table</code>。</p>
<p>我们一个个分析，在分析<code>def_idts</code>之前首先得看几个宏，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G(_vector, _addr, _ist, _type, _dpl, _segment)	\</span></span><br><span class="line"><span class="meta">	&#123;						\</span></span><br><span class="line"><span class="meta">		.vector		= _vector,		\</span></span><br><span class="line"><span class="meta">		.bits.ist	= _ist,			\</span></span><br><span class="line"><span class="meta">		.bits.type	= _type,		\</span></span><br><span class="line"><span class="meta">		.bits.dpl	= _dpl,			\</span></span><br><span class="line"><span class="meta">		.bits.p		= 1,			\</span></span><br><span class="line"><span class="meta">		.addr		= _addr,		\</span></span><br><span class="line"><span class="meta">		.segment	= _segment,		\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupt gate */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTG(_vector, _addr)				\</span></span><br><span class="line"><span class="meta">	G(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)</span></span><br><span class="line"><span class="comment">/* System interrupt gate */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSG(_vector, _addr)				\</span></span><br><span class="line"><span class="meta">	G(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL3, __KERNEL_CS)</span></span><br></pre></td></tr></table></figure>

<p>于是便可知道其内容为x86架构下中断门描述符，其格式如下，其实IDT（INTERRUPT DESCRIPTOR TABLE）表中的表项，该表由IDTR寄存器指向，其格式如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgimage-20220426205810991.png" alt="image-20220426205810991"></p>
<p><img src="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgx86%20%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="image-20220426171754324"></p>
<p>最后再来看手册里一张图，这张图大有门道，首先可以看到Linux中用<code>__KERNEL_CS</code>作为其段描述符，也就是图中的GDT表中的索引，而我们知道Linux使用的是平坦内存模型，所以段基址为0，也就导致offset就是异常处理函数的地址。</p>
<p><img src="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgx86-interrupt%20call.png" alt="image-20220426173926048"></p>
<p>​	上述过程将IDT表设置好之后，在后面会通过调用<code>load_idt(&amp;idt_descr);</code>将描述符写入IDTR寄存器，至此就完成了IDT的初始化。</p>
<h3 id="异常向量处理函数"><a href="#异常向量处理函数" class="headerlink" title="异常向量处理函数"></a>异常向量处理函数</h3><p>前面我们说到把IDT的内容填充完，使得CPU硬件能够找到异常向量处理函数的入口地址，接下来我们来看这些函数内部是如何处理的。</p>
<p>在文件<code>arch/x86/kernel/traps.c</code>中有类似如下的定义，可以看到这些定义大部分最后都会调用的<code>do_error_trap</code>来进行处理。也有一部分是自己实现的函数，自己调用。只不过这部分的C代码定义有点难看懂，知道异常处理后面到这来了就行。(老的kernel版本是通过汇编中定义的DO_ERROR函数来作为统一的入口，新的kernel现在改了，下一节我们会讲。这也是因此网上和很多书上都讲解的是DO_ERROR和do_sym那一套)。实际上下面的代码显示的code并不是在IDT表中填充的地址，硬件上虽然设计了可以让进程在触发异常时跳转到异常处理函数的硬件逻辑，但是Linux不是那么做的，Linux将所有IDT表项中call的异常处理函数地址是一个统一的入口，该入口会在下一节讲解。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_IDTENTRY(func)						\</span></span><br><span class="line"><span class="meta">static __always_inline void __##func(struct pt_regs *regs);		\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">DEFINE_IDTENTRY(exc_divide_error)</span><br><span class="line">&#123;</span><br><span class="line">	do_error_trap(regs, <span class="number">0</span>, <span class="string">&quot;divide error&quot;</span>, X86_TRAP_DE, SIGFPE,</span><br><span class="line">		      FPE_INTDIV, error_get_trap_addr(regs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_IDTENTRY(exc_overflow)</span><br><span class="line">&#123;</span><br><span class="line">	do_error_trap(regs, <span class="number">0</span>, <span class="string">&quot;overflow&quot;</span>, X86_TRAP_OF, SIGSEGV, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">DEFINE_IDTENTRY_ERRORCODE(exc_invalid_tss)</span><br><span class="line">&#123;</span><br><span class="line">	do_error_trap(regs, error_code, <span class="string">&quot;invalid TSS&quot;</span>, X86_TRAP_TS, SIGSEGV,</span><br><span class="line">		      <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_IDTENTRY_ERRORCODE(exc_segment_not_present)</span><br><span class="line">&#123;</span><br><span class="line">	do_error_trap(regs, error_code, <span class="string">&quot;segment not present&quot;</span>, X86_TRAP_NP,</span><br><span class="line">		      SIGBUS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>OK，总之异常处理我们现在知道最后走到了<code>do_error_trap</code>，我们看看这个函数里面是什么东西，同样是traps.c文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_error_trap</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">long</span> error_code, <span class="type">char</span> *str,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">long</span> trapnr, <span class="type">int</span> signr, <span class="type">int</span> sicode, <span class="type">void</span> __user *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCU_LOCKDEP_WARN(!rcu_is_watching(), <span class="string">&quot;entry code didn&#x27;t wake RCU&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) !=</span><br><span class="line">			NOTIFY_STOP) &#123;</span><br><span class="line">		cond_local_irq_enable(regs);</span><br><span class="line">		do_trap(trapnr, signr, str, regs, error_code, sicode, addr);</span><br><span class="line">		cond_local_irq_disable(regs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_trap</span><span class="params">(<span class="type">int</span> trapnr, <span class="type">int</span> signr, <span class="type">char</span> *str, <span class="keyword">struct</span> pt_regs *regs,</span></span><br><span class="line"><span class="params">	<span class="type">long</span> error_code, <span class="type">int</span> sicode, <span class="type">void</span> __user *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!do_trap_no_signal(tsk, trapnr, str, regs, error_code))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	show_signal(tsk, signr, <span class="string">&quot;trap &quot;</span>, str, regs, error_code);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sicode)</span><br><span class="line">		force_sig(signr);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		force_sig_fault(signr, sicode, addr);</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(do_trap);</span><br></pre></td></tr></table></figure>

<p>可以看到，很多处理过程最后都走到了<code>do_trap</code>函数里，且该函数里通过发送一些信号给进程来进行处理异常，而进程收到信号之后会执行信号处理函数。</p>
<h3 id="真正的从用户态陷入内核态执行的代码"><a href="#真正的从用户态陷入内核态执行的代码" class="headerlink" title="真正的从用户态陷入内核态执行的代码"></a>真正的从用户态陷入内核态执行的代码</h3><p>​	很多细心的人应该发现，调用异常处理函数的时候会有一个参数pt_regs, 也就是说明这个函数其实不是真正填到中断向量表里跳转的函数，而是后面分发的函数，那么问题就来了，pt_regs参数是什么，是在什么时候构造的？接下来我们就来讲解真正的从用户态陷入内核态执行的代码逻辑。前方包含大量复杂的汇编和宏，很晦涩难懂。</p>
<p>​	首先Linux-kernel在<code>arch/x86/entry/entry.S</code>中定义了所有内核的入口函数，其中idtentry（idt entry，这样就明白了）函数就是真正写在IDT表中的地址，其代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * idtentry - Macro to generate entry stubs for simple IDT entries</span><br><span class="line"> * @vector:		Vector number</span><br><span class="line"> * @asmsym:		ASM symbol for the entry point</span><br><span class="line"> * @cfunc:		C function to be called</span><br><span class="line"> * @has_error_code:	Hardware pushed error code on stack</span><br><span class="line"> *</span><br><span class="line"> * The macro emits code to set up the kernel context for straight forward</span><br><span class="line"> * and simple IDT entries. No IST stack, no paranoid entry checks.</span><br><span class="line"> */</span><br><span class="line">.macro idtentry vector asmsym cfunc has_error_code:req</span><br><span class="line">SYM_CODE_START(\asmsym)</span><br><span class="line">	UNWIND_HINT_IRET_REGS offset=\has_error_code*8</span><br><span class="line">	ASM_CLAC</span><br><span class="line"></span><br><span class="line">	.if \has_error_code == 0</span><br><span class="line">		pushq	$-1			/* ORIG_RAX: no syscall to restart */</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	.if \vector == X86_TRAP_BP</span><br><span class="line">		/*</span><br><span class="line">		 * If coming from kernel space, create a 6-word gap to allow the</span><br><span class="line">		 * int3 handler to emulate a call instruction.</span><br><span class="line">		 */</span><br><span class="line">		testb	$3, CS-ORIG_RAX(%rsp)</span><br><span class="line">		jnz	.Lfrom_usermode_no_gap_\@</span><br><span class="line">		.rept	6</span><br><span class="line">		pushq	5*8(%rsp)</span><br><span class="line">		.endr</span><br><span class="line">		UNWIND_HINT_IRET_REGS offset=8</span><br><span class="line">.Lfrom_usermode_no_gap_\@:</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	idtentry_body \cfunc \has_error_code</span><br><span class="line"></span><br><span class="line">_ASM_NOKPROBE(\asmsym)</span><br><span class="line">SYM_CODE_END(\asmsym)</span><br><span class="line">.endm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>稍微分析一下，idtentry是一个生成IDT entries的宏，其会生成一个函数，该函数接收一个vecter参数，一个asmsym参数，一个cfunc参数，一个has_error_code参数，其参数说明都在注释里。</p>
<p>但是在执行这个函数之前，也就是在CPU自动跳转到异常处理函数的同时，cpu硬件上会做一些事情，首先他会到TSS中(tr寄存器指向的一个硬件上下文表在GDT中的索引，该表在CPU设计的本意是用于硬件上下文的保存，但是Linux并不那么做，Linux用软件进行保存，而在其中存了kernel stack的地址，tss结构在linux中定义如下)找到kernel stack，其中<code>sp0</code>字段存储了内核栈的地址（64位和32位的定义有所不同，不过这是架构相关内容，得看手册，太细的东西就没必要知道那么清楚了）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x86_hw_tss</span> &#123;</span></span><br><span class="line">	u32			reserved1;</span><br><span class="line">	u64			sp0;</span><br><span class="line">	u64			sp1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since Linux does not use ring 2, the &#x27;sp2&#x27; slot is unused by</span></span><br><span class="line"><span class="comment">	 * hardware.  entry_SYSCALL_64 uses it as scratch space to stash</span></span><br><span class="line"><span class="comment">	 * the user RSP value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64			sp2;</span><br><span class="line"></span><br><span class="line">	u64			reserved2;</span><br><span class="line">	u64			ist[<span class="number">7</span>];</span><br><span class="line">	u32			reserved3;</span><br><span class="line">	u32			reserved4;</span><br><span class="line">	u16			reserved5;</span><br><span class="line">	u16			io_bitmap_base;</span><br><span class="line"></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>切换到内核栈之后，CPU还会自动将寄存器压栈，压栈顺序如下图(error code由软件压)，左边是32位，右边是64位，最先入栈是SS，然后是RSP，因为内核栈是从上往下增长的。其中的error code字段有些异常处理会有，有些没有，所以在<code>idtentry()</code>宏中13~18行会进行判断是否有error code，如果有会开辟error code的空间并压栈。</p>
<p><img src="https://raw.githubusercontent.com/unsatisfying/picture-server/main/imgimage-20220426212350991.png" alt="image-20220426212350991"></p>
<p>接着函数就运行<code>idtentry_body \cfunc \has_error_code</code>到了idtentry_body函数处，该函数定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * idtentry_body - Macro to emit code calling the C function</span><br><span class="line"> * @cfunc:		C function to be called</span><br><span class="line"> * @has_error_code:	Hardware pushed error code on stack</span><br><span class="line"> */</span><br><span class="line">.macro idtentry_body cfunc has_error_code:req</span><br><span class="line"></span><br><span class="line">	call	error_entry</span><br><span class="line">	UNWIND_HINT_REGS</span><br><span class="line"></span><br><span class="line">	movq	%rsp, %rdi			/* pt_regs pointer into 1st argument*/</span><br><span class="line"></span><br><span class="line">	.if \has_error_code == 1</span><br><span class="line">		movq	ORIG_RAX(%rsp), %rsi	/* get error code into 2nd argument*/</span><br><span class="line">		movq	$-1, ORIG_RAX(%rsp)	/* no syscall to restart */</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	call	\cfunc</span><br><span class="line"></span><br><span class="line">	jmp	error_return</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>该函数在error_entry函数中构造pt_reg结构体，即把用户态的旧寄存器压栈，然后将栈顶指针(rsp指向pt_reg结构体，该结构体是栈上空间构造的)传递给rdi，我们都知道rdi是x64函数调用的第一个参数，也就终于回到了前面所提的参数是pt_regs的问题了，所以这里call \cfunc才是前面<code>DEFINE_IDTENTRY</code>定义的真正函数，而该参数也是从idtentry中一直传递下来的，相当于:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IDT表指向</span><br><span class="line">-&gt;idtentry(<span class="built_in">vector</span>, asmsym, cfunc, has_error_code)</span><br><span class="line">	-&gt;idtentry_body(cfun, has_error_code)</span><br><span class="line">		-&gt;cfunc(pt_regs)</span><br></pre></td></tr></table></figure>

<p>终于清楚了所有的逻辑，我们最后看看error_entry中怎么做的把。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Save all registers in pt_regs, and switch GS if needed.</span><br><span class="line"> */</span><br><span class="line">SYM_CODE_START_LOCAL(error_entry)</span><br><span class="line">	UNWIND_HINT_FUNC</span><br><span class="line">	cld</span><br><span class="line">	PUSH_AND_CLEAR_REGS save_ret=1</span><br><span class="line">	ENCODE_FRAME_POINTER 8</span><br><span class="line">	testb	$3, CS+8(%rsp)</span><br><span class="line">	jz	.Lerror_kernelspace</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We entered from user mode or we&#x27;re pretending to have entered</span><br><span class="line">	 * from user mode due to an IRET fault.</span><br><span class="line">	 */</span><br><span class="line">	SWAPGS</span><br><span class="line">	FENCE_SWAPGS_USER_ENTRY</span><br><span class="line">	/* We have user CR3.  Change to kernel CR3. */</span><br><span class="line">	SWITCH_TO_KERNEL_CR3 scratch_reg=%rax</span><br><span class="line"></span><br><span class="line">.Lerror_entry_from_usermode_after_swapgs:</span><br><span class="line">	/* Put us onto the real thread stack. */</span><br><span class="line">	popq	%r12				/* save return addr in %12 */</span><br><span class="line">	movq	%rsp, %rdi			/* arg0 = pt_regs pointer */</span><br><span class="line">	call	sync_regs</span><br><span class="line">	movq	%rax, %rsp			/* switch stack */</span><br><span class="line">	ENCODE_FRAME_POINTER</span><br><span class="line">	pushq	%r12</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">.Lerror_entry_done_lfence:</span><br><span class="line">	FENCE_SWAPGS_KERNEL_ENTRY</span><br><span class="line">.Lerror_entry_done:</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * There are two places in the kernel that can potentially fault with</span><br><span class="line">	 * usergs. Handle them here.  B stepping K8s sometimes report a</span><br><span class="line">	 * truncated RIP for IRET exceptions returning to compat mode. Check</span><br><span class="line">	 * for these here too.</span><br><span class="line">	 */</span><br><span class="line">.Lerror_kernelspace:</span><br><span class="line">	leaq	native_irq_return_iret(%rip), %rcx</span><br><span class="line">	cmpq	%rcx, RIP+8(%rsp)</span><br><span class="line">	je	.Lerror_bad_iret</span><br><span class="line">	movl	%ecx, %eax			/* zero extend */</span><br><span class="line">	cmpq	%rax, RIP+8(%rsp)</span><br><span class="line">	je	.Lbstep_iret</span><br><span class="line">	cmpq	$.Lgs_change, RIP+8(%rsp)</span><br><span class="line">	jne	.Lerror_entry_done_lfence</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * hack: .Lgs_change can fail with user gsbase.  If this happens, fix up</span><br><span class="line">	 * gsbase and proceed.  We&#x27;ll fix up the exception and land in</span><br><span class="line">	 * .Lgs_change&#x27;s error handler with kernel gsbase.</span><br><span class="line">	 */</span><br><span class="line">	SWAPGS</span><br><span class="line">	FENCE_SWAPGS_USER_ENTRY</span><br><span class="line">	jmp .Lerror_entry_done</span><br><span class="line"></span><br><span class="line">.Lbstep_iret:</span><br><span class="line">	/* Fix truncated RIP */</span><br><span class="line">	movq	%rcx, RIP+8(%rsp)</span><br><span class="line">	/* fall through */</span><br><span class="line"></span><br><span class="line">.Lerror_bad_iret:</span><br><span class="line">	/*</span><br><span class="line">	 * We came from an IRET to user mode, so we have user</span><br><span class="line">	 * gsbase and CR3.  Switch to kernel gsbase and CR3:</span><br><span class="line">	 */</span><br><span class="line">	SWAPGS</span><br><span class="line">	FENCE_SWAPGS_USER_ENTRY</span><br><span class="line">	SWITCH_TO_KERNEL_CR3 scratch_reg=%rax</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Pretend that the exception came from user mode: set up pt_regs</span><br><span class="line">	 * as if we faulted immediately after IRET.</span><br><span class="line">	 */</span><br><span class="line">	mov	%rsp, %rdi</span><br><span class="line">	call	fixup_bad_iret</span><br><span class="line">	mov	%rax, %rsp</span><br><span class="line">	jmp	.Lerror_entry_from_usermode_after_swapgs</span><br><span class="line">SYM_CODE_END(error_entry)</span><br></pre></td></tr></table></figure>

<p>其通过调用<code>PUSH_AND_CLEAR_REGS</code>构造pt_regs结构体，将相应的通用寄存器入栈。</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.macro PUSH_AND_CLEAR_REGS rdx=<span class="built_in">%rdx</span> rax=<span class="built_in">%rax</span> save_ret=<span class="number">0</span></span><br><span class="line">	PUSH_REGS rdx=\rdx, rax=\rax, save_ret=\save_ret</span><br><span class="line">	CLEAR_REGS</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macro PUSH_REGS rdx=<span class="built_in">%rdx</span> rax=<span class="built_in">%rax</span> save_ret=<span class="number">0</span></span><br><span class="line">	.<span class="keyword">if</span> \save_ret</span><br><span class="line">	pushq	<span class="built_in">%rsi</span>		<span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">	movq	<span class="number">8</span>(<span class="built_in">%rsp</span>), <span class="built_in">%rsi</span>	<span class="comment">/* temporarily store the return address in %rsi */</span></span><br><span class="line">	movq	<span class="built_in">%rdi</span>, <span class="number">8</span>(<span class="built_in">%rsp</span>)	<span class="comment">/* pt_regs-&gt;di (overwriting original return address) */</span></span><br><span class="line">	.<span class="keyword">else</span></span><br><span class="line">	pushq   <span class="built_in">%rdi</span>		<span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">	pushq   <span class="built_in">%rsi</span>		<span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">	.endif</span><br><span class="line">	pushq	\rdx		<span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">	pushq   <span class="built_in">%rcx</span>		<span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">	pushq   \rax		<span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">	pushq   <span class="built_in">%r</span>8		<span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">	pushq   <span class="built_in">%r</span>9		<span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">	pushq   <span class="built_in">%r</span>10		<span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">	pushq   <span class="built_in">%r</span>11		<span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">	pushq	<span class="built_in">%rbx</span>		<span class="comment">/* pt_regs-&gt;rbx */</span></span><br><span class="line">	pushq	<span class="built_in">%rbp</span>		<span class="comment">/* pt_regs-&gt;rbp */</span></span><br><span class="line">	pushq	<span class="built_in">%r</span>12		<span class="comment">/* pt_regs-&gt;r12 */</span></span><br><span class="line">	pushq	<span class="built_in">%r</span>13		<span class="comment">/* pt_regs-&gt;r13 */</span></span><br><span class="line">	pushq	<span class="built_in">%r</span>14		<span class="comment">/* pt_regs-&gt;r14 */</span></span><br><span class="line">	pushq	<span class="built_in">%r</span>15		<span class="comment">/* pt_regs-&gt;r15 */</span></span><br><span class="line">	UNWIND_HINT_REGS</span><br><span class="line"></span><br><span class="line">	.<span class="keyword">if</span> \save_ret</span><br><span class="line">	pushq	<span class="built_in">%rsi</span>		<span class="comment">/* return address on top of stack */</span></span><br><span class="line">	.endif</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>接着后面就不细讲了，其中16行有一个SWAPGS指令，其会交换kernel的CR3和user的CR3，CR3是页表基址，很多人会问地址空间kernel和user不是一起的吗，其实这里是由于KPTI的缘故，因为熔断meltdown和幽灵specter的硬件缺陷导致的漏洞，内核采用了KPTI，将用户页表和内核页表隔离来防止用户通过侧信道攻击获取内核数据，这里便是KPTI的体现，具体自己去查资料。</p>
<p>最后贴一个pt_regs结构体定义，省的读者去找，看了之后是不是突然就明了了栈上的寄存器存储的顺序（64位的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ax;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cx;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> dx;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> si;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> di;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> orig_ax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ip;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="有始有终"><a href="#有始有终" class="headerlink" title="有始有终"></a>有始有终</h3><p>执行完了异常处理函数，总得返回用户态把，再来看看返回时候的逻辑。在idtentry_body函数中最后会<code>jmp error_return</code>返回，其会判断保存的cs是kernel的还是user的，如果是user则返回user，如果是kernel返回kernel。毕竟执行kernel代码也可能出现异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START_LOCAL(error_return)</span><br><span class="line">	UNWIND_HINT_REGS</span><br><span class="line">	DEBUG_ENTRY_ASSERT_IRQS_OFF</span><br><span class="line">	testb	$3, CS(%rsp)</span><br><span class="line">	jz	restore_regs_and_return_to_kernel</span><br><span class="line">	jmp	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">SYM_CODE_END(error_return)</span><br></pre></td></tr></table></figure>

<p>然后截取几段比较重要的，和弹出寄存器相关的代码，其中POP_REGS弹出相关寄存器，然后通过iretq指令会弹出最后的SS:RSP,得到存储的用户&#x2F;内核栈进行返回。这里嵌套了很多跳转的地方，总而言之最后都会到iretq的指令，中间细节就不细讲了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START_LOCAL(common_interrupt_return)</span><br><span class="line">SYM_INNER_LABEL(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)</span><br><span class="line">	POP_REGS pop_rdi=0</span><br><span class="line">	addq	$8, %rsp	/* skip regs-&gt;orig_ax */</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	popq	%rdi</span><br><span class="line">	SWAPGS</span><br><span class="line">	INTERRUPT_RETURN	/*#define INTERRUPT_RETURN	jmp native_iret*/</span><br><span class="line">SYM_INNER_LABEL(restore_regs_and_return_to_kernel, SYM_L_GLOBAL)</span><br><span class="line">	POP_REGS</span><br><span class="line">	addq	$8, %rsp	/* skip regs-&gt;orig_ax */</span><br><span class="line">	/*</span><br><span class="line">	 * ARCH_HAS_MEMBARRIER_SYNC_CORE rely on IRET core serialization</span><br><span class="line">	 * when returning from IPI handler.</span><br><span class="line">	 */</span><br><span class="line">	INTERRUPT_RETURN  /*#define INTERRUPT_RETURN	jmp native_iret*/</span><br><span class="line">SYM_INNER_LABEL_ALIGN(native_iret, SYM_L_GLOBAL)</span><br><span class="line">	UNWIND_HINT_IRET_REGS</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(native_irq_return_iret, SYM_L_GLOBAL)	</span><br><span class="line">	iretq</span><br><span class="line">SYM_CODE_END(common_interrupt_return)</span><br><span class="line">_ASM_NOKPROBE(common_interrupt_return)</span><br></pre></td></tr></table></figure>



<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>讲完了异常再来讲中断。还是一样的过程，先是初始化，然后是发生中断时候的逻辑，最后是退出中断的逻辑。</p>
<h3 id="中断向量初始化"><a href="#中断向量初始化" class="headerlink" title="中断向量初始化"></a>中断向量初始化</h3><p>中断向量初始化的函数调用逻辑如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start_kernel()</span><br><span class="line">    -&gt;init_IRQ()</span><br><span class="line">        -&gt;native_init_IRQ()</span><br><span class="line">            -&gt;idt_setup_apic_and_irq_gates()</span><br><span class="line">                -&gt;idt_setup_from_table(idt_table, apic_idts, ARRAY_SIZE(apic_idts), <span class="literal">true</span>);</span><br><span class="line">			for_each_clear_bit_from(i, system_vectors, FIRST_SYSTEM_VECTOR) &#123;</span><br><span class="line">				entry = irq_entries_start + <span class="number">8</span> * (i - FIRST_EXTERNAL_VECTOR);</span><br><span class="line">				set_intr_gate(i, entry);</span><br><span class="line">			&#125;</span><br><span class="line">                -&gt;load_idt(&amp;idt_descr);</span><br></pre></td></tr></table></figure>

<p>又是熟悉的操作呗，<code>idt_setup_from_table</code>函数把<code>apic_idts</code>的内容拷贝到<code>idt_table</code>,上面讲过<code>idt_table</code>是什么，这里我们就看看<code>apic_idts</code>定义,哈哈明了了，又是一样的东西：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> __initconst <span class="class"><span class="keyword">struct</span> <span class="title">idt_data</span> <span class="title">apic_idts</span>[] =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	INTG(RESCHEDULE_VECTOR,			asm_sysvec_reschedule_ipi),</span><br><span class="line">	INTG(CALL_FUNCTION_VECTOR,		asm_sysvec_call_function),</span><br><span class="line">	INTG(CALL_FUNCTION_SINGLE_VECTOR,	asm_sysvec_call_function_single),</span><br><span class="line">	INTG(IRQ_MOVE_CLEANUP_VECTOR,		asm_sysvec_irq_move_cleanup),</span><br><span class="line">	INTG(REBOOT_VECTOR,			asm_sysvec_reboot),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_THERMAL_VECTOR</span></span><br><span class="line">	INTG(THERMAL_APIC_VECTOR,		asm_sysvec_thermal),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_MCE_THRESHOLD</span></span><br><span class="line">	INTG(THRESHOLD_APIC_VECTOR,		asm_sysvec_threshold),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_MCE_AMD</span></span><br><span class="line">	INTG(DEFERRED_ERROR_VECTOR,		asm_sysvec_deferred_error),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_LOCAL_APIC</span></span><br><span class="line">	INTG(LOCAL_TIMER_VECTOR,		asm_sysvec_apic_timer_interrupt),</span><br><span class="line">	INTG(X86_PLATFORM_IPI_VECTOR,		asm_sysvec_x86_platform_ipi),</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_HAVE_KVM</span></span><br><span class="line">	INTG(POSTED_INTR_VECTOR,		asm_sysvec_kvm_posted_intr_ipi),</span><br><span class="line">	INTG(POSTED_INTR_WAKEUP_VECTOR,		asm_sysvec_kvm_posted_intr_wakeup_ipi),</span><br><span class="line">	INTG(POSTED_INTR_NESTED_VECTOR,		asm_sysvec_kvm_posted_intr_nested_ipi),</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_IRQ_WORK</span></span><br><span class="line">	INTG(IRQ_WORK_VECTOR,			asm_sysvec_irq_work),</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">	INTG(SPURIOUS_APIC_VECTOR,		asm_sysvec_spurious_apic_interrupt),</span><br><span class="line">	INTG(ERROR_APIC_VECTOR,			asm_sysvec_error_interrupt),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h3><p>​	还是同样的，瞅瞅中断处理函数的定义吧，这里截取了一小部分，熟悉的DECLARE_IDTENTRY宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* System vector entry points */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_LOCAL_APIC</span></span><br><span class="line">DECLARE_IDTENTRY_SYSVEC(ERROR_APIC_VECTOR,		sysvec_error_interrupt);</span><br><span class="line">DECLARE_IDTENTRY_SYSVEC(SPURIOUS_APIC_VECTOR,		sysvec_spurious_apic_interrupt);</span><br><span class="line">DECLARE_IDTENTRY_SYSVEC(LOCAL_TIMER_VECTOR,		sysvec_apic_timer_interrupt);</span><br><span class="line">DECLARE_IDTENTRY_SYSVEC(X86_PLATFORM_IPI_VECTOR,	sysvec_x86_platform_ipi);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">DECLARE_IDTENTRY(RESCHEDULE_VECTOR,			sysvec_reschedule_ipi);</span><br><span class="line">DECLARE_IDTENTRY_SYSVEC(IRQ_MOVE_CLEANUP_VECTOR,	sysvec_irq_move_cleanup);</span><br><span class="line">DECLARE_IDTENTRY_SYSVEC(REBOOT_VECTOR,			sysvec_reboot);</span><br><span class="line">DECLARE_IDTENTRY_SYSVEC(CALL_FUNCTION_SINGLE_VECTOR,	sysvec_call_function_single);</span><br><span class="line">DECLARE_IDTENTRY_SYSVEC(CALL_FUNCTION_VECTOR,		sysvec_call_function);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>​	当然函数内容也截取一小部分，就是真正处理中断的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_IDTENTRY_SYSVEC_SIMPLE(sysvec_reschedule_ipi)</span><br><span class="line">&#123;</span><br><span class="line">	ack_APIC_irq();</span><br><span class="line">	trace_reschedule_entry(RESCHEDULE_VECTOR);</span><br><span class="line">	inc_irq_stat(irq_resched_count);</span><br><span class="line">	scheduler_ipi();</span><br><span class="line">	trace_reschedule_exit(RESCHEDULE_VECTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_IDTENTRY_SYSVEC(sysvec_apic_timer_interrupt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> =</span> set_irq_regs(regs);</span><br><span class="line"></span><br><span class="line">	ack_APIC_irq();</span><br><span class="line">	trace_local_timer_entry(LOCAL_TIMER_VECTOR);</span><br><span class="line">	local_apic_timer_interrupt();</span><br><span class="line">	trace_local_timer_exit(LOCAL_TIMER_VECTOR);</span><br><span class="line"></span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>当然上面列出的是有中断处理函数定义的地方，但是不是所有的32~127号中断向量都被定义了的，肯定会有一些空缺，空缺的地方怎么填呢，回忆一下中断向量初始化的函数调用逻辑，可以看到在函数<code>idt_setup_apic_and_irq_gates</code>有那么一部分代码，如下所示，其将IDT中空缺的位置用irq_entries_start加上了一个偏移填充，也就是跳转到了irq_entries_start数组中某个index的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for_each_clear_bit_from(i, system_vectors, FIRST_SYSTEM_VECTOR) &#123;</span><br><span class="line">	entry = irq_entries_start + <span class="number">8</span> * (i - FIRST_EXTERNAL_VECTOR);</span><br><span class="line">	set_intr_gate(i, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK我们来看看irq_entries_start里面是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	.align 8</span><br><span class="line">SYM_CODE_START(irq_entries_start)</span><br><span class="line">    vector=FIRST_EXTERNAL_VECTOR</span><br><span class="line">    .rept NR_EXTERNAL_VECTORS</span><br><span class="line">	UNWIND_HINT_IRET_REGS</span><br><span class="line">0 :</span><br><span class="line">	.byte	0x6a, vector</span><br><span class="line">	jmp	asm_common_interrupt</span><br><span class="line">	nop</span><br><span class="line">	/* Ensure that the above is 8 bytes max */</span><br><span class="line">	. = 0b + 8</span><br><span class="line">	vector = vector+1</span><br><span class="line">    .endr</span><br><span class="line">SYM_CODE_END(irq_entries_start)</span><br></pre></td></tr></table></figure>

<p>看不懂没关系，其实这个数组中填充了8字节的汇编指令，每8字节都是如下的形式。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span><span class="built_in">x6a</span>(push) xxx </span><br><span class="line"><span class="number">0</span><span class="built_in">xe9</span>(jmp) asm_common_interrupt</span><br><span class="line"><span class="number">0</span><span class="built_in">x90</span>(nop)</span><br></pre></td></tr></table></figure>

<p>也就是往栈上push了一个向量号，然后跳转到<code>asm_common_interrupt</code>处。</p>
<h3 id="真正陷入内核态执行的地方"><a href="#真正陷入内核态执行的地方" class="headerlink" title="真正陷入内核态执行的地方"></a>真正陷入内核态执行的地方</h3><p>上回书我们说到<code>asm_common_interrupt</code>的地方，这边是中断处理的真正函数入口点。其定义如下，也用到了DECLARE_IDTENTRY_IRQ。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">DECLARE_IDTENTRY_IRQ(X86_TRAP_OTHER,	common_interrupt);</span><br></pre></td></tr></table></figure>

<p>那就跟之前一样了，跟异常那块串起来了，也是跳到idtentry的汇编代码处，然后，硬件把一些寄存器压栈，软件上会构造pt_regs，等等，都是异常处理部分讲过的内容，最后会调用<code>common_interrupt</code>函数。我们来看看<code>common_interrupt</code>做了什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_IDTENTRY_IRQ(common_interrupt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> =</span> set_irq_regs(regs);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* entry code tells RCU that we&#x27;re not quiescent.  Check it. */</span></span><br><span class="line">	RCU_LOCKDEP_WARN(!rcu_is_watching(), <span class="string">&quot;IRQ failed to wake up RCU&quot;</span>);</span><br><span class="line"></span><br><span class="line">	desc = __this_cpu_read(vector_irq[<span class="built_in">vector</span>]);</span><br><span class="line">	<span class="keyword">if</span> (likely(!IS_ERR_OR_NULL(desc))) &#123;</span><br><span class="line">		handle_irq(desc, regs);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ack_APIC_irq();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (desc == VECTOR_UNUSED) &#123;</span><br><span class="line">			pr_emerg_ratelimited(<span class="string">&quot;%s: %d.%u No irq handler for vector\n&quot;</span>,</span><br><span class="line">					     __func__, smp_processor_id(),</span><br><span class="line">					     <span class="built_in">vector</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			__this_cpu_write(vector_irq[<span class="built_in">vector</span>], VECTOR_UNUSED);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，总之就是对中断进行一些处理，如果描述表中没有会报<code>No irq handler for vector</code>等等，然后又是中断返回那一套，具体看异常处理中有始有终章节即可。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用也经过过时代的变迁，首先早期的系统执行系统调用时候，即通过INT指令调用，INT指令的作用是触发一个中断向量，其参数作为中断向量号，而处理器执行<code>INT 0x80</code>便是系统调用的中断向量号(0x80,128)。但是现在处理器有了新的指令SYSCALL指令，其也是x86_64内核默认使用的方法，64位的defconfig没有下面两个config选项了。所以这里我们将两种方式都进行讲解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IA32_EMULATION)</span></span><br><span class="line">	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_X86_32)</span></span><br><span class="line">	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="int-0x80"><a href="#int-0x80" class="headerlink" title="int 0x80"></a>int 0x80</h3><p>首先是老式的办法，通过指令触发中断，执行INT指令，然后触发0x80中断向量进行系统调用处理，如果在64位内核上要强制使用需要打开上述config，随后便和前述逻辑中的处理方式一样，进入<code>entry_INT80_compat</code>的汇编代码入口处，而32位使用的入口是<code>entry_INT80_32</code>，这里我们就看看64位的吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(entry_INT80_compat)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line">	/*</span><br><span class="line">	 * Interrupts are off on entry.</span><br><span class="line">	 */</span><br><span class="line">	ASM_CLAC			/* Do this early to minimize exposure */</span><br><span class="line">	SWAPGS</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * User tracing code (ptrace or signal handlers) might assume that</span><br><span class="line">	 * the saved RAX contains a 32-bit number when we&#x27;re invoking a 32-bit</span><br><span class="line">	 * syscall.  Just in case the high bits are nonzero, zero-extend</span><br><span class="line">	 * the syscall number.  (This could almost certainly be deleted</span><br><span class="line">	 * with no ill effects.)</span><br><span class="line">	 */</span><br><span class="line">	movl	%eax, %eax</span><br><span class="line"></span><br><span class="line">	/* switch to thread stack expects orig_ax and rdi to be pushed */</span><br><span class="line">	pushq	%rax			/* pt_regs-&gt;orig_ax */</span><br><span class="line">	pushq	%rdi			/* pt_regs-&gt;di */</span><br><span class="line"></span><br><span class="line">	/* Need to switch before accessing the thread stack. */</span><br><span class="line">	SWITCH_TO_KERNEL_CR3 scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">	/* In the Xen PV case we already run on the thread stack. */</span><br><span class="line">	ALTERNATIVE &quot;&quot;, &quot;jmp .Lint80_keep_stack&quot;, X86_FEATURE_XENPV</span><br><span class="line"></span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">	pushq	6*8(%rdi)		/* regs-&gt;ss */</span><br><span class="line">	pushq	5*8(%rdi)		/* regs-&gt;rsp */</span><br><span class="line">	pushq	4*8(%rdi)		/* regs-&gt;eflags */</span><br><span class="line">	pushq	3*8(%rdi)		/* regs-&gt;cs */</span><br><span class="line">	pushq	2*8(%rdi)		/* regs-&gt;ip */</span><br><span class="line">	pushq	1*8(%rdi)		/* regs-&gt;orig_ax */</span><br><span class="line">	pushq	(%rdi)			/* pt_regs-&gt;di */</span><br><span class="line">.Lint80_keep_stack:</span><br><span class="line"></span><br><span class="line">	pushq	%rsi			/* pt_regs-&gt;si */</span><br><span class="line">	xorl	%esi, %esi		/* nospec   si */</span><br><span class="line">	pushq	%rdx			/* pt_regs-&gt;dx */</span><br><span class="line">	xorl	%edx, %edx		/* nospec   dx */</span><br><span class="line">	pushq	%rcx			/* pt_regs-&gt;cx */</span><br><span class="line">	xorl	%ecx, %ecx		/* nospec   cx */</span><br><span class="line">	pushq	$-ENOSYS		/* pt_regs-&gt;ax */</span><br><span class="line">	pushq   %r8			/* pt_regs-&gt;r8 */</span><br><span class="line">	xorl	%r8d, %r8d		/* nospec   r8 */</span><br><span class="line">	pushq   %r9			/* pt_regs-&gt;r9 */</span><br><span class="line">	xorl	%r9d, %r9d		/* nospec   r9 */</span><br><span class="line">	pushq   %r10			/* pt_regs-&gt;r10*/</span><br><span class="line">	xorl	%r10d, %r10d		/* nospec   r10 */</span><br><span class="line">	pushq   %r11			/* pt_regs-&gt;r11 */</span><br><span class="line">	xorl	%r11d, %r11d		/* nospec   r11 */</span><br><span class="line">	pushq   %rbx                    /* pt_regs-&gt;rbx */</span><br><span class="line">	xorl	%ebx, %ebx		/* nospec   rbx */</span><br><span class="line">	pushq   %rbp                    /* pt_regs-&gt;rbp */</span><br><span class="line">	xorl	%ebp, %ebp		/* nospec   rbp */</span><br><span class="line">	pushq   %r12                    /* pt_regs-&gt;r12 */</span><br><span class="line">	xorl	%r12d, %r12d		/* nospec   r12 */</span><br><span class="line">	pushq   %r13                    /* pt_regs-&gt;r13 */</span><br><span class="line">	xorl	%r13d, %r13d		/* nospec   r13 */</span><br><span class="line">	pushq   %r14                    /* pt_regs-&gt;r14 */</span><br><span class="line">	xorl	%r14d, %r14d		/* nospec   r14 */</span><br><span class="line">	pushq   %r15                    /* pt_regs-&gt;r15 */</span><br><span class="line">	xorl	%r15d, %r15d		/* nospec   r15 */</span><br><span class="line"></span><br><span class="line">	UNWIND_HINT_REGS</span><br><span class="line"></span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	do_int80_syscall_32</span><br><span class="line">	jmp	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">SYM_CODE_END(entry_INT80_compat)</span><br></pre></td></tr></table></figure>

<p>粗略讲一下：2-29行大概就是一些关中断，然后处理KPTI等等的一些处理过程，随后是进行pt_regs构建压栈，最后调用（call）<code>do_int80_syscall_32</code>函数，其会从pt_regs中读取相应的系统调用号，然后进行相应的处理，就不过多叙述了。最后就是<code>swapgs_restore_regs_and_return_to_usermode</code>，就是处理KPTI，将寄存器弹出，然后返回用户态balabala一大堆。</p>
<h3 id="SYSCALL-SYSENTER指令方式"><a href="#SYSCALL-SYSENTER指令方式" class="headerlink" title="SYSCALL&#x2F;SYSENTER指令方式"></a>SYSCALL&#x2F;SYSENTER指令方式</h3><p>该指令会从<code>IA32_LSTAR_MSR</code>寄存器中取出系统调用入口到RIP寄存器，然后执行相应的系统调用统一入口函数，其方式比上述方式快。那么Linux内核中怎么做的呢，下面一一道来：</p>
<h4 id="寄存器初始化"><a href="#寄存器初始化" class="headerlink" title="寄存器初始化"></a>寄存器初始化</h4><p>在<code>arch/x86/kernel/cpu/common.c</code>文件中的syscall_init函数对寄存器进行初始化，其通过wrmsr将<code>entry_SYSCALL_64</code>的系统调用入口写入<code>MSR_LSTAR</code>寄存器(Linux定义的寄存器名字)，也就是上面所说的<code>IA32_LSTAR_MSR</code>（Intel定义的寄存器名字）。下面代码也可以看到如果开启了32位等选项，也可以使用SYSCALL指令进行跳转到<code>entry_SYSCALL_compat</code>处，该函数前面一节已经分析了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	wrmsr(MSR_STAR, <span class="number">0</span>, (__USER32_CS &lt;&lt; <span class="number">16</span>) | __KERNEL_CS);</span><br><span class="line">	wrmsrl(MSR_LSTAR, (<span class="type">unsigned</span> <span class="type">long</span>)entry_SYSCALL_64);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IA32_EMULATION</span></span><br><span class="line">	wrmsrl(MSR_CSTAR, (<span class="type">unsigned</span> <span class="type">long</span>)entry_SYSCALL_compat);</span><br><span class="line">	.....</span><br></pre></td></tr></table></figure>

<h4 id="调用SYSCALL指令前后"><a href="#调用SYSCALL指令前后" class="headerlink" title="调用SYSCALL指令前后"></a>调用SYSCALL指令前后</h4><p>OK我们来看看<code>entry_SYSCALL_64</code>里面做了什么，首先猜一下应该就是硬件寄存器压栈，软件把寄存器压栈，跳转系统调用函数，处理完成返回那一套呗。就把代码都贴上了，粗略看一下果然就是那么做的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(entry_SYSCALL_64)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	swapgs</span><br><span class="line">	/* tss.sp2 is scratch space. */</span><br><span class="line">	movq	%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)</span><br><span class="line">	SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br><span class="line">	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)</span><br><span class="line"></span><br><span class="line">	/* Construct struct pt_regs on stack */</span><br><span class="line">	pushq	$__USER_DS				/* pt_regs-&gt;ss */</span><br><span class="line">	pushq	PER_CPU_VAR(cpu_tss_rw + TSS_sp2)	/* pt_regs-&gt;sp */</span><br><span class="line">	pushq	%r11					/* pt_regs-&gt;flags */</span><br><span class="line">	pushq	$__USER_CS				/* pt_regs-&gt;cs */</span><br><span class="line">	pushq	%rcx					/* pt_regs-&gt;ip */</span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)</span><br><span class="line">	pushq	%rax					/* pt_regs-&gt;orig_ax */</span><br><span class="line"></span><br><span class="line">	PUSH_AND_CLEAR_REGS rax=$-ENOSYS</span><br><span class="line"></span><br><span class="line">	/* IRQs are off. */</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	/* Sign extend the lower 32bit as syscall numbers are treated as int */</span><br><span class="line">	movslq	%eax, %rsi</span><br><span class="line">	call	do_syscall_64		/* returns with IRQs disabled */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Try to use SYSRET instead of IRET if we&#x27;re returning to</span><br><span class="line">	 * a completely clean 64-bit userspace context.  If we&#x27;re not,</span><br><span class="line">	 * go to the slow exit path.</span><br><span class="line">	 * In the Xen PV case we must use iret anyway.</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	ALTERNATIVE &quot;&quot;, &quot;jmp	swapgs_restore_regs_and_return_to_usermode&quot;, \</span><br><span class="line">		X86_FEATURE_XENPV</span><br><span class="line"></span><br><span class="line">	movq	RCX(%rsp), %rcx</span><br><span class="line">	movq	RIP(%rsp), %r11</span><br><span class="line"></span><br><span class="line">	cmpq	%rcx, %r11	/* SYSRET requires RCX == RIP */</span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP</span><br><span class="line">	 * in kernel space.  This essentially lets the user take over</span><br><span class="line">	 * the kernel, since userspace controls RSP.</span><br><span class="line">	 *</span><br><span class="line">	 * If width of &quot;canonical tail&quot; ever becomes variable, this will need</span><br><span class="line">	 * to be updated to remain correct on both old and new CPUs.</span><br><span class="line">	 *</span><br><span class="line">	 * Change top bits to match most significant bit (47th or 56th bit</span><br><span class="line">	 * depending on paging mode) in the address.</span><br><span class="line">	 */</span><br><span class="line">#ifdef CONFIG_X86_5LEVEL</span><br><span class="line">	ALTERNATIVE &quot;shl $(64 - 48), %rcx; sar $(64 - 48), %rcx&quot;, \</span><br><span class="line">		&quot;shl $(64 - 57), %rcx; sar $(64 - 57), %rcx&quot;, X86_FEATURE_LA57</span><br><span class="line">#else</span><br><span class="line">	shl	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx</span><br><span class="line">	sar	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* If this changed %rcx, it was not canonical */</span><br><span class="line">	cmpq	%rcx, %r11</span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	cmpq	$__USER_CS, CS(%rsp)		/* CS must match SYSRET */</span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	movq	R11(%rsp), %r11</span><br><span class="line">	cmpq	%r11, EFLAGS(%rsp)		/* R11 == RFLAGS */</span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot</span><br><span class="line">	 * restore RF properly. If the slowpath sets it for whatever reason, we</span><br><span class="line">	 * need to restore it correctly.</span><br><span class="line">	 *</span><br><span class="line">	 * SYSRET can restore TF, but unlike IRET, restoring TF results in a</span><br><span class="line">	 * trap from userspace immediately after SYSRET.  This would cause an</span><br><span class="line">	 * infinite loop whenever #DB happens with register state that satisfies</span><br><span class="line">	 * the opportunistic SYSRET conditions.  For example, single-stepping</span><br><span class="line">	 * this user code:</span><br><span class="line">	 *</span><br><span class="line">	 *           movq	$stuck_here, %rcx</span><br><span class="line">	 *           pushfq</span><br><span class="line">	 *           popq %r11</span><br><span class="line">	 *   stuck_here:</span><br><span class="line">	 *</span><br><span class="line">	 * would never get past &#x27;stuck_here&#x27;.</span><br><span class="line">	 */</span><br><span class="line">	testq	$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11</span><br><span class="line">	jnz	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	/* nothing to check for RSP */</span><br><span class="line"></span><br><span class="line">	cmpq	$__USER_DS, SS(%rsp)		/* SS must match SYSRET */</span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We win! This label is here just for ease of understanding</span><br><span class="line">	 * perf profiles. Nothing jumps here.</span><br><span class="line">	 */</span><br><span class="line">syscall_return_via_sysret:</span><br><span class="line">	/* rcx and r11 are already restored (see code above) */</span><br><span class="line">	POP_REGS pop_rdi=0 skip_r11rcx=1</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Now all regs are restored except RSP and RDI.</span><br><span class="line">	 * Save old stack pointer and switch to trampoline stack.</span><br><span class="line">	 */</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	movq	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	pushq	RSP-RDI(%rdi)	/* RSP */</span><br><span class="line">	pushq	(%rdi)		/* RDI */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We are on the trampoline stack.  All regs except RDI are live.</span><br><span class="line">	 * We can do future final exit work right here.</span><br><span class="line">	 */</span><br><span class="line">	STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">	SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">	popq	%rdi</span><br><span class="line">	popq	%rsp</span><br><span class="line">	swapgs</span><br><span class="line">	sysretq</span><br><span class="line">SYM_CODE_END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure>

<p>首先2-9行由于SYSCALL指令没有IDT表那一块硬件逻辑，硬件不会自动加载TSS中的内核栈位置给寄存器，所以需要手动用软件的方式进行加载内核栈地址，也是从tss结构体中加载。然后看注释就知道，就构建pt_regs结构体，之后27行call了<code>do_syscall_64</code>，进行真正的系统调用处理，然后最后都会到<code>swapgs_restore_regs_and_return_to_usermode</code>进行返回，大差不差。</p>
<h4 id="do-syscall-64进行系统调用处理"><a href="#do-syscall-64进行系统调用处理" class="headerlink" title="do_syscall_64进行系统调用处理"></a>do_syscall_64进行系统调用处理</h4><p>行吧，具体逻辑就不说了，贴个代码看看就行了，大概就是读一下系统调用号，然后跳转到相应的系统调用处理函数进行执行，然后返回就完了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__visible noinstr <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	add_random_kstack_offset();	<span class="comment">//ASLR，安全问题，就给栈加了个偏移</span></span><br><span class="line">	nr = syscall_enter_from_user_mode(regs, nr); <span class="comment">//一些初始化的处理，检查等操作</span></span><br><span class="line"></span><br><span class="line">	instrumentation_begin();<span class="comment">//KMSAN相关操作，如果没开选项则为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//do_syscall_x64处理64位系统调用，里面会调用系统调用表中的函数，x32就是32位的，不过是运行在64位kernel上的32位程序使用的</span></span><br><span class="line">	<span class="keyword">if</span> (!do_syscall_x64(regs, nr) &amp;&amp; !do_syscall_x32(regs, nr) &amp;&amp; nr != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="comment">/* Invalid system call, but still a system call. */</span></span><br><span class="line">		regs-&gt;ax = __x64_sys_ni_syscall(regs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	instrumentation_end();<span class="comment">//同前</span></span><br><span class="line">	syscall_exit_to_user_mode(regs);<span class="comment">//退出之前的最后处理，什么开关中断啊什么的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Linux-kernel source code 5.15</p>
<p>Intel spec</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/os/" rel="tag"># os</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/19/note/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%861/" rel="prev" title="内存管理1">
                  <i class="fa fa-angle-left"></i> 内存管理1
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/08/paper_reading/Fuzz/HyperFuzzer/" rel="next" title="HyperFuzzer：An Efficient Hybrid Fuzzer for Virtual CPUs">
                  HyperFuzzer：An Efficient Hybrid Fuzzer for Virtual CPUs <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zhuzhuzai</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/unsatisfying" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
  

      
        <script async src=https://cdn.jsdelivr.net/npm/hexo-next-mouse-effect@latest/click/fireWorks.js></script>
      

      s
        <script async src=https://cdn.jsdelivr.net/npm/hexo-next-mouse-effect@latest/move/fairyDustCursor.js></script>
      
    
</body>
</html>
